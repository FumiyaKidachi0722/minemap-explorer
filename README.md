# Minemap Explorer

Next.js 15 と React 19、TypeScript を用いたマインクラフトワールド閲覧アプリです。

## セットアップ

```bash
npm install
npm run dev
```

ブラウザで <http://localhost:3000> を開きます。

## プロジェクト方針

- `presentation/components/ui` に shadcn/ui の基本コンポーネントを配置
- 新規 UI 部品は `src/presentation/components` 以下に追加
- `domain` / `application` / `infrastructure` / `presentation` の構造を維持

## 概要

- マインクラフトワールドをリアルタイム取得して 3D 表示
- 一人称視点と俯瞰マップビューを切り替え
- Three.js または Babylon.js での実装を比較検討
- Next.js 15 + React 19 を活かしたパフォーマンス最適化
- ハザードマップに適した簡潔なビジュアル表現
- Vercel 無料プランでの運用制限の整理
- `/viewer-sample` ページで簡易ビューアを表示
- `/viewer-sample` ページではサンプルワールドをWASD操作で歩き回れます
- `/world` ページでは BlueMap 出力のサンプルチャンク( Base64 形式 )を読み込み実際のワールドを表示します

調査完了後、開発フローとサンプル実装をご提案します。

ありがとうございます。Next.js 15 + React 19 + TypeScript を用いて、マイクラの街（ワールド全体・リアルタイム更新あり）を Web 上で探検できるアプリを作成するために、以下の観点から最適な技術スタックとアーキテクチャを調査します。

- マインクラフトのワールドデータをリアルタイムで取得・変換・同期する方法（例：API連携、サーバーMOD、外部ツール）
- Webブラウザ上で一人称視点・俯瞰ビューを実装するための最適な3Dエンジン（Three.js, Babylon.js 等）
- Next.js 15 + React 19 に最適な統合手法とパフォーマンス最適化策
- ハザードマップ用途に適した UI 表現・UX デザインの参考例
- 無料プランの Vercel 上で動作可能な範囲（データ量・CDN制限・ランタイムなど）

調査完了後、開発フローとサンプル設計を含めてご提案いたします。

# マインクラフトワールドWeb探索アプリ構築提案

本提案では、**Next.js 15**（App Router）と**React 19**および**TypeScript**を用いて、マインクラフトのワールドデータ（全ワールド、リアルタイム更新を含む）をWebブラウザ上で探索できるアプリケーションの構築方法を示します。要求されている一人称視点での歩行と俯瞰マップビューの切替機能、ハザードマップ用途に適した視覚表現、リアルタイムなワールドデータ同期、最新のNext.js/Reactに最適化した実装、そしてVercel無料プランでのホスティング制約への対応について、それぞれベストプラクティスに基づいて検討します。

## UI設計：一人称視点と俯瞰マップビューの切替

ユーザーは自由に**一人称視点**（主観視点）でワールド内を歩き回り、任意のタイミングで**俯瞰マップビュー**に切り替えて全体を見渡せるようにします。これには、3Dエンジン上でカメラのモードを動的に変更する仕組みを導入します。具体的には、**Perspectiveカメラ**による一人称視点と、真上から地形を見下ろす**Orthographicカメラ**による俯瞰図を用意し、UI上のボタンまたはキー入力で二つの視点をトグルできるようにします。視点の切替に伴い、**操作方法**も自動で変化させます。一人称視点ではキーボードWASD＋マウス（Pointer Lockによる視点操作）でキャラクター移動、俯瞰ビューではドラッグやスクロールで地図を移動・ズームするUIが適切です。

一人称視点での歩行については**カメラの高さ**を地面上1.8ブロック程度に設定し、重力・ジャンプや障害物衝突を処理します。軽量な実装として、各移動ステップで移動先座標にブロックが存在するかをチェックする**シンプルな当たり判定**を導入すれば、物理エンジンを使わなくとも壁や地形との衝突を表現できます（ブロック単位のグリッド衝突のため実装容易）。より高度な実装では3Dエンジンの**物理システム**を利用してカメラにコリジョンを持たせることも可能です。例えばBabylon.jsには標準で**衝突検知と重力**の機能があり、カメラに当たり判定用の楕円体（エリipsoid）を設定することで壁にぶつからず地面に立つ一人称移動がほぼ設定不要で実現できます。Three.jsの場合はデフォルトで物理エンジンを含まないため、Ammo.jsやCannon.js等を組み込むか、自前でブロック単位の衝突判定ロジックを書く必要があります。本提案では実装の容易さとメンテナンス性を考慮し、**簡易的な衝突判定**による歩行をまず採用し、必要に応じて物理エンジン導入を検討します。またBlueMap開発者も「自律移動できる一人称モードを追加するなら、衝突検知無しのフリーフライトになるだろう」と言及しており、衝突処理の実装は難易度が高い点に留意が必要です。

俯瞰マップビューでは**全体地図**としての見やすさを重視し、カメラを真上から見下ろす正投影に設定します。UI上に北方向や縮尺を示す要素を配置し、地図として直感的に操作できるようにします。必要に応じて2Dのタイルマップをオーバーレイ表示する方法も考えられますが、ここでは3Dシーン内のカメラを切り替えることで対応します。視点間のスムーズな移行演出（フェードやアニメーション）を加えることでユーザビリティを向上させます。また、一人称↔俯瞰の切替時に現在位置を維持し、俯瞰モードではユーザ位置にマーカーを表示するなど、**コンテキストを保った状態で視点だけ変更**されるよう配慮します。こうしたUI切替ロジックや状態（視点モードのフラグ）はReactの状態管理（`useState`や`useReducer`）で扱い、Reactコンポーネントツリー内でモードに応じて適切なカメラ・コントローラをレンダリングする設計とします。

## ハザードマップ用途に適した視覚表現

ハザードマップとして利用できるよう、**視覚表現は情報の強調と簡潔さ**を重視します。マインクラフト既存のテクスチャをそのまま表示すると視覚情報が過剰でノイズになり得るため、本アプリではブロックの種類や高さに応じて**単色または簡易シェーディング**で表現する方針です。例えば、地形の高度によって色調を変える高度分布図や、特定ブロック（例：水や溶岩、砂利など危険に関わるブロック）を目立つ色でハイライト表示するなど、**リスク度合いを色分け**して表示します。必要に応じて透明なカラーレイヤーで危険区域（例：浸水想定区域など）を覆う、等高線やグリッドを表示するといった工夫も検討します。これによりユーザーは地形や危険箇所を一目で把握でき、ハザードマップ用途に適した**わかりやすいビジュアル**となります。

具体的な実装としては、3Dエンジン上でブロックのレンダリング時に使う**Material**をカスタマイズします。Three.jsの場合、MeshBasicMaterialを用いてライティングの影響を排したフラットな色調で描画したり、カスタムシェーダーで高度による色分けやブロック属性による発光を表現できます。一例として、英国地質調査所（BGS）のプロジェクトでは地質情報を示すためブロックを従来の地質図の色で**色付きガラスブロック**に置き換え、一目で地層の広がりを可視化する工夫をしています。同様に、本アプリでも**独自のカラーパレット**を定義し、ブロックIDや座標から割り当てることで、ゲーム本来のテクスチャではなく意味的に色付けされた世界を描画します。こうすることで地形の形状は維持しつつ、ハザード情報に焦点を当てた抽象化ビューを提供できます。

また、**描画負荷軽減**のために不要な細部を省略します。例えば内部が見えない地中のブロックや裏側のフェイスは描画しないメッシュ最適化（いわゆる**グリーディー法によるメッシュ統合**）を行い、描画ポリゴン数を大幅に削減します。BlueMapでもJavaプラグイン側でチャンクごとに3Dモデルを生成する際、隣接するブロック面を統合するなどの最適化を行い、生成されるモデルデータ量を抑えています。さらに生成モデルは**gzip圧縮**することでデータ転送量を約20%程度まで削減できると報告されています。本アプリでも事前計算したメッシュデータをgzip等で圧縮し、クライアント側で展開して使用することで通信負荷を減らします。Vercel上でホスティングする場合も、圧縮された静的ファイルに対して適切な`Content-Encoding: gzip`ヘッダを付与して配信することで、ブラウザが自動的に解凍し効率的にモデルをロードできます。

最後に、ハザードマップ用途では**視認性**が重要なため、昼夜の概念は不要なら**常に昼間の明るい状態**でレンダリングします。3Dエンジンの照明設定を固定し、影のコントラストを弱めるか、いっそ影描写を省略することで、影によって重要な情報が見えにくくなることを防ぎます。必要に応じて2D UI上に凡例（色の意味説明）や現在の座標・方角表示を配置し、ユーザが地図として活用できるよう配慮します。

## WebGLエンジン選定とライブラリ構成

**WebGL 3Dエンジンの選定**は、本アプリの性能と開発効率に直結します。候補として挙げられているThree.jsとBabylon.jsについて、特徴と本プロジェクトへの適合性を比較し、最適な選択を提案します。

- **Three.js**: WebGL向けの軽量なレンダリングライブラリで、シンプルながら必要な機能はプラグイン等で拡張可能です。Three.js自体はあくまで描画エンジンであり、物理演算や高度なGUIなどは含まれませんが、その分**ミニマルな構成**で柔軟にカスタマイズできます。Three.jsは**Reactエコシステムとの親和性**が高く、特に人気のある`react-three-fiber`(R3F)ライブラリを使うと、Three.jsのシーンをReactのJSXコンポーネントとして宣言的に記述でき、Reactの状態管理やコンテキストを活用したインタラクティブな3D UI開発が可能です。コミュニティも非常に大きく、サンプルやサードパーティ製のコントロール・ローダー（例えば`OrbitControls`や各種ローダー）も充実しています。そのため**学習リソースが豊富**でトラブルシューティングもしやすい点が利点です。

- **Babylon.js**: Microsoftが支援するフル機能の3Dゲームエンジンで、Three.jsより後発ながら**包括的な機能**を備えています。特筆すべきは、物理エンジン（Cannon.jsやAmmo.js等）との統合、VR/AR対応、シーンエディタやGUIウィジェットなどがエンジンに組み込まれている点です。Babylon.jsは**カメラ制御が充実**しており、初期状態で複数のカメラモード（自由視点カメラ、追跡カメラ、ArcRotateカメラなど）を備え、Orbit操作やズーム、一人称視点での移動も追加ライブラリなしで即利用できます。また**物理演算や衝突判定が標準サポート**されており、重力の適用やオブジェクト同士の当たり判定も少ない設定で有効化できます。反面、Three.jsに比べエンジン自体がやや重量級で、APIも包括的な分だけ取っつきにくさがあります。ただし公式ドキュメントは整備されており、Microsoftの支援による**長期的な安定性**も期待できます。Reactとの統合についてはThree.jsほど一般的ではないものの、`react-babylonjs`というコミュニティライブラリが存在し、JSX記述でBabylonシーンを構築することも可能です。

本アプリの要件に照らし合わせると、**どちらのエンジンでも実現自体は可能**です。一人称・俯瞰視点の切替やブロック世界のレンダリング、リアルタイムデータ更新等はThree.jsでもBabylon.jsでも対応できます。ただし、**実装のしやすさ**と**パフォーマンス**の観点から若干の違いがあります。まず、一人称視点の移動や衝突処理を考えると、Babylon.jsは初めからその機能が揃っているため開発コストが低めです。一方、Three.jsでもPointerLockControls（マウスルックによる移動）や簡易的な重力表現を自作することで対応できますが、ある程度の追加実装が必要になります。次に、Reactへの統合という点では、Reactコンポーネントとして3Dシーンを組み込むやり方に習熟している開発者が多いThree.js＋R3Fの方がスムーズでしょう。**コミュニティの強さ**も無視できません。Three.jsは利用者数が多く、多様なプラグインやQ&A蓄積があるため、未知の問題に直面しても情報を得やすい利点があります。

以上を踏まえ、本提案では**Three.jsを選定**し、Reactとの親和性を高めるため**react-three-fiber**を利用する構成を第一候補とします。Three.js＋R3Fなら、UI要素をReactで構築しつつそのまま3DシーンもJSXで管理でき、状態共有やイベントハンドリングが容易です。例えばワールド内オブジェクトのクリックイベントをReact側で処理したり、UIパネルと連動したカメラ操作を実装するのが容易になるメリットがあります。一方、Babylon.jsについても物理衝突など特定機能の実装簡易さから**代替案**として検討価値があります。特に「ブロックにぶつからずに歩く」「傾斜に沿って自然に降りる」といった物理挙動を重視する場合は、Babylon.jsの**カメラ衝突機能**を使うほうが結果的に実装が短期間で安定する可能性があります。最終的な選択はチームの習熟度にも依存しますが、**Reactに精通したWeb開発者主体であればThree.js＋R3F**、**ゲーム開発経験があり物理表現重視ならBabylon.js**という基準で判断します。なおどちらを採用する場合でも、TypeScriptの型定義が公式提供されているため型安全に開発できます。また補助ライブラリとして、Three.jsなら`@react-three/drei`（便利コンポーネント集）や`three-stdlib`（各種ControlsやLoaderの集合）、Babylon.jsなら公式GUIライブラリやInspectorなど、必要に応じて組み込んで開発効率を高めます。
以上を踏まえ、本提案では**Three.jsを選定**し、Reactとの親和性を高めるため**react-three-fiber**を利用する構成を第一候補とします。Three.js＋R3Fなら、UI要素をReactで構築しつつそのまま3DシーンもJSXで管理でき、状態共有やイベントハンドリングが容易です。例えばワールド内オブジェクトのクリックイベントをReact側で処理したり、UIパネルと連動したカメラ操作を実装するのが容易になるメリットがあります。一方、Babylon.jsについても物理衝突など特定機能の実装簡易さから**代替案**として検討価値があります。特に「ブロックにぶつからずに歩く」「傾斜に沿って自然に降りる」といった物理挙動を重視する場合は、Babylon.jsの**カメラ衝突機能**を使うほうが結果的に実装が短期間で安定する可能性があります。最終的な選択はチームの習熟度にも依存しますが、**Reactに精通したWeb開発者主体であればThree.js＋R3F**、**ゲーム開発経験があり物理表現重視ならBabylon.js**という基準で判断します。なおどちらを採用する場合でも、TypeScriptの型定義が公式提供されているため型安全に開発できます。また補助ライブラリとして、Three.jsなら`@react-three/drei`（便利コンポーネント集）や`three-stdlib`（各種ControlsやLoaderの集合）、Babylon.jsなら公式GUIライブラリやInspectorなど、必要に応じて組み込んで開発効率を高めます。

## マインクラフトワールドデータのリアルタイム取得・同期

**マインクラフトのワールドデータをリアルタイムに取得・同期**する方法は、本プロジェクトの中核となる技術課題です。マインクラフト（Java版）のワールドは通常、サーバーまたはシングルプレイ環境で更新され続ける**Anvil形式**（拡張子`.mca`のリージョンファイル群）で保存されています。このデータをWebアプリ側で取得し、ユーザが見る3Dシーンに反映する必要があります。また、ゲーム内でブロックの変更や追加が発生した際には、その差分をできるだけリアルタイムにWebにも反映する仕組みが求められます。
以上を踏まえ、本提案では**Three.jsを選定**し、Reactとの親和性を高めるため**react-three-fiber**を利用する構成を第一候補とします。Three.js＋R3Fなら、UI要素をReactで構築しつつそのまま3DシーンもJSXで管理でき、状態共有やイベントハンドリングが容易です。例えばワールド内オブジェクトのクリックイベントをReact側で処理したり、UIパネルと連動したカメラ操作を実装するのが容易になるメリットがあります。一方、Babylon.jsについても物理衝突など特定機能の実装簡易さから**代替案**として検討価値があります。特に「ブロックにぶつからずに歩く」「傾斜に沿って自然に降りる」といった物理挙動を重視する場合は、Babylon.jsの**カメラ衝突機能**を使うほうが結果的に実装が短期間で安定する可能性があります。最終的な選択はチームの習熟度にも依存しますが、**Reactに精通したWeb開発者主体であればThree.js＋R3F**、**ゲーム開発経験があり物理表現重視ならBabylon.js**という基準で判断します。なおどちらを採用する場合でも、TypeScriptの型定義が公式提供されているため型安全に開発できます。また補助ライブラリとして、Three.jsなら`@react-three/drei`（便利コンポーネント集）や`three-stdlib`（各種ControlsやLoaderの集合）、Babylon.jsなら公式GUIライブラリやInspectorなど、必要に応じて組み込んで開発効率を高めます。
以上を踏まえ、本提案では**Three.jsを選定**し、Reactとの親和性を高めるため**react-three-fiber**を利用する構成を第一候補とします。Three.js＋R3Fなら、UI要素をReactで構築しつつそのまま3DシーンもJSXで管理でき、状態共有やイベントハンドリングが容易です。例えばワールド内オブジェクトのクリックイベントをReact側で処理したり、UIパネルと連動したカメラ操作を実装するのが容易になるメリットがあります。一方、Babylon.jsについても物理衝突など特定機能の実装簡易さから**代替案**として検討価値があります。特に「ブロックにぶつからずに歩く」「傾斜に沿って自然に降りる」といった物理挙動を重視する場合は、Babylon.jsの**カメラ衝突機能**を使うほうが結果的に実装が短期間で安定する可能性があります。最終的な選択はチームの習熟度にも依存しますが、**Reactに精通したWeb開発者主体であればThree.js＋R3F**、**ゲーム開発経験があり物理表現重視ならBabylon.js**という基準で判断します。なおどちらを採用する場合でも、TypeScriptの型定義が公式提供されているため型安全に開発できます。また補助ライブラリとして、Three.jsなら`@react-three/drei`（便利コンポーネント集）や`three-stdlib`（各種ControlsやLoaderの集合）、Babylon.jsなら公式GUIライブラリやInspectorなど、必要に応じて組み込んで開発効率を高めます.
以上を踏まえ、本提案では**Three.jsを選定**し、Reactとの親和性を高めるため**react-three-fiber**を利用する構成を第一候補とします。Three.js＋R3Fなら、UI要素をReactで構築しつつそのまま3DシーンもJSXで管理でき、状態共有やイベントハンドリングが容易です。
例えばワールド内オブジェクトのクリックイベントをReact側で処理したり、UIパネルと連動したカメラ操作を実装するのが容易になるメリットがあります。一方、Babylon.jsについても物理衝突など特定機能の実装簡易さから**代替案**として検討価値があります。
特に「ブロックにぶつからずに歩く」「傾斜に沿って自然に降りる」といった物理挙動を重視する場合は、Babylon.jsの**カメラ衝突機能**を使うほうが結果的に実装が短期間で安定する可能性があります。
最終的な選択はチームの習熟度にも依存しますが、**Reactに精通したWeb開発者主体であればThree.js＋R3F**、**ゲーム開発経験があり物理表現重視ならBabylon.js**という基準で判断します。
なおどちらを採用する場合でも、TypeScriptの型定義が公式提供されているため型安全に開発できます。また補助ライブラリとして、Three.jsなら`@react-three/drei`（便利コンポーネント集）や`three-stdlib`（各種ControlsやLoaderの集合）、Babylon.jsなら公式GUIライブラリやInspectorなど、必要に応じて組み込んで開発効率を高めます。

## マインクラフトワールドデータのリアルタイム取得・同期

**マインクラフトのワールドデータをリアルタイムに取得・同期**する方法は、本プロジェクトの中核となる技術課題です。マインクラフト（Java版）のワールドは通常、サーバーまたはシングルプレイ環境で更新され続ける**Anvil形式**（拡張子`.mca`のリージョンファイル群）で保存されています。このデータをWebアプリ側で取得し、ユーザが見る3Dシーンに反映する必要があります。また、ゲーム内でブロックの変更や追加が発生した際には、その差分をできるだけリアルタイムにWebにも反映する仕組みが求められます。

実現方法としていくつかのアプローチが考えられます。

- **(A) サーバーサイドMOD/プラグインの活用**: 最も堅実なのは、マインクラフトサーバー側で専用のプラグインやMODを導入し、ワールドデータをWebに提供する手段を用意することです。例えば**BlueMap**はサーバー上でワールドデータを読み取り3Dモデルへ変換し、内蔵のWebサーバー経由で表示するプラグインです。BlueMapを導入すればサーバーがワールド変更を監視して自動でモデルデータを更新し続けるため、クライアント側（本提案のNext.jsアプリ）はその出力を読み込んで表示するだけでリアルタイム同期を実現できます。BlueMapはワールドをチャンク単位で**タイル化**したJSONモデル（独自の圧縮形式PRBM）やテクスチャ情報を出力するため、当アプリからそれら静的ファイルにアクセスしてThree.js等で描画します。BlueMapの内蔵サーバーを使わず、**外部Webサーバー**でホスティングすることも可能で、BlueMapが生成したファイル郡を例えばVercelの静的ファイルとして配置することも検討できます。ただしワールド全域のモデルデータは膨大になるため、Vercel無料プランのストレージや帯域制限内に収めるには、生成範囲を必要最低限に絞るなどの工夫が必要です（例えば重要エリアのみ事前レンダリングし、他は要求に応じて都度レンダリング）。他にもDynmapやPl3xMapなどのマップ系プラグインがありますが、これらは主に2D俯瞰タイル画像を生成するもので、一人称3D表示にはBlueMapが適しています。
- **(A) サーバーサイドMOD/プラグインの活用**: 最も堅実なのは、マインクラフトサーバー側で専用のプラグインやMODを導入し、ワールドデータをWebに提供する手段を用意することです。
  例えば**BlueMap**はサーバー上でワールドデータを読み取り3Dモデルへ変換し、内蔵のWebサーバー経由で表示するプラグインです。BlueMapを導入すればサーバーがワールド変更を監視して自動でモデルデータを更新し続けるため、クライアント側（本提案のNext.jsアプリ）はその出力を読み込んで表示するだけでリアルタイム同期を実現できます。
  BlueMapはワールドをチャンク単位で**タイル化**したJSONモデル（独自の圧縮形式PRBM）やテクスチャ情報を出力するため、当アプリからそれら静的ファイルにアクセスしてThree.js等で描画します。BlueMapの内蔵サーバーを使わず、**外部Webサーバー**でホスティングすることも可能で、BlueMapが生成したファイル郡を例えばVercelの静的ファイルとして配置することも検討できます。
  ただしワールド全域のモデルデータは膨大になるため、Vercel無料プランのストレージや帯域制限内に収めるには、生成範囲を必要最低限に絞るなどの工夫が必要です（例えば重要エリアのみ事前レンダリングし、他は要求に応じて都度レンダリング）。他にもDynmapやPl3xMapなどのマップ系プラグインがありますが、これらは主に2D俯瞰タイル画像を生成するもので、一人称3D表示にはBlueMapが適しています。
- **(B) ワールドデータファイルを直接読み込む**: 外部プラグインに頼らずに、Next.jsアプリ側で直接`.mca`ファイル（Anvilフォーマット）を読み取る方法です。この場合、Node.js上でNBTデータをパースしブロック情報を取得するライブラリが必要になります。幸い**PrismarineJS**プロジェクト由来の各種ライブラリ（例えば`prismarine-nbt`や`prismarine-chunk`、`minecraft-region`等）が存在し、Java版ワールドデータを解析可能です。実際、PrismarineJSのツールを利用してサーバー側でマップデータを読み込み、ブラウザでThree.js描画するデモ実装も公開されています。これらを用いて実装する場合、基本手順は以下のようになります。
  1. **サーバー側処理**: Next.jsのAPI Routesやサーバーコンポーネント内で、`.mca`ファイルから特定範囲のブロックデータを読み出す。例として、あるチャンク(16x16x256ブロック)のデータを取得するエンドポイント`/api/chunk?x=??&z=??`を用意し、その中でファイルを開いてNBTをパースし、各ブロックIDを配列化する。
  2. **クライアント側処理**: API経由で取得したブロック配列をもとにメッシュを構築しThree.jsシーンに適用する。メッシュ構築時に隣接ブロックとの境界だけ面を生成するなど、先述のメッシュ最適化もここで行います。
  3. **リアルタイム更新**: 一定間隔でAPIに変更確認を問い合わせるか、あるいは**サーバーからプッシュ通知**する仕組みを作ります。例えば一定時間ごとに対象チャンクのデータを再取得し、前回と差分があればThree.jsオブジェクトを更新する、といったポーリング方式が実装容易です。可能であればWebSocketを用いて、サーバー側でワールドの更新イベント発生時に該当チャンク座標をクライアントに送信し、クライアントがそのチャンクデータを再取得する形にすれば無駄がありません。Bukkit/Spigotプラグインでワールド変更イベントをフックし、外部のNodeサーバー（Next.js）に通知する仕組みを組むことも技術的には可能です。
     PrismarineJSを用いる方法は**柔軟ですが、開発労力が大きい**点に注意が必要です。特に、Minecraftのブロック種類（Block State）を正確に再現しようとすると、ブロックモデルやテクスチャ情報も別途必要になります。実例として公開されているminecraft-mapper-jsでは、Minecraft公式の`assets`から`blockstates`や`models`、`textures`フォルダを入手してクライアントに組み込み、Three.jsでブロック形状を忠実に描画しています。しかし本アプリでは前述のとおり**簡易な表現**に留めるため、ブロック形状は基本立方体で問題なく、テクスチャも使用しない方針です。従って、PrismarineJSで取得するのは**各座標のブロックID**程度で足ります。そこから先の「どの色・マテリアルで描くか」はアプリ側のロジックでブロックID→色変換テーブルをもとに設定します。こうした割り切りにより、データ転送量や処理負荷を下げつつ必要十分な情報をユーザに提供します。
- **(C) その他のインターフェース**: この他、**Minecraft公式の提供するAPI**（Bedrock版ではGameTest/Bridge APIなど）を利用する手もありますが、Java版では標準APIは存在せずMOD/プラグインに頼ることになります。またRCONプロトコルを介してサーバーにコマンドを送りデータを取得することも考えられます。RCONはサーバーコンソールコマンドを実行できるので、カスタムのプラグインを用意し「指定範囲のブロック情報をテキスト出力するコマンド」を実装すれば、Next.jsからRCON経由でそのコマンドを叩き結果を受け取る、といった通信も可能です。しかしRCONはステートレスな単発要求であり常時接続には向かないこと、また上記のようなブロックダンプコマンドを自作するなら最初からHTTP APIを実装した方が効率的であることから、RCONはあまり現実的ではありません。
  以上の選択肢の中では、**実装の容易さと実績**から**(A)サーバープラグイン方式**が最有力です。特にBlueMapプラグインはニーズに合致しており、データ変換や軽量化のベストプラクティスが詰まっています。BlueMapでは初回にワールド全体をモデル化する重い処理が走りますが、一度完了すれば**以降は変更のあったチャンクのみを逐次変換する**ため効率的です。BlueMapの出力するモデルファイル（`.prbm.gz`やテクスチャJSON等）はVercel上のホスティングにもそのまま流用可能です。例えばBlueMapを導入したサーバーで定期的に`/bluemap purge`（再レンダリング）を行い、出力ディレクトリをVercelにデプロイするCIパイプラインを組めば、半リアルタイム（数分おき程度）の更新でも問題ないでしょう。よりリアルタイム性が必要であれば、BlueMapのWebSocketライブ機能や、あるいは完全自前実装で(B)のように差分適用するか、(B)と(A)の中間的に**BlueMapの生成したデータをNext.js側で適宜Fetchして反映**する方法も考えられます。例えばBlueMapのREST APIやディレクトリに対し、クライアントが定期的に「このチャンクのモデルが更新されたか？」を問い合わせ、更新されていれば新たに取得してシーンを置き換えるという仕組みです。BlueMap自体はブラウザ上で「Update Map」ボタンを押すと最新タイルを取得しますが、これを自動化するイメージです。
  以上の選択肢の中では、**実装の容易さと実績**から**(A)サーバープラグイン方式**が最有力です。特にBlueMapプラグインはニーズに合致しており、データ変換や軽量化のベストプラクティスが詰まっています。
  BlueMapでは初回にワールド全体をモデル化する重い処理が走りますが、一度完了すれば**以降は変更のあったチャンクのみを逐次変換する**ため効率的です。BlueMapの出力するモデルファイル（`.prbm.gz`やテクスチャJSON等）はVercel上のホスティングにもそのまま流用可能です。
  例えばBlueMapを導入したサーバーで定期的に`/bluemap purge`（再レンダリング）を行い、出力ディレクトリをVercelにデプロイするCIパイプラインを組めば、半リアルタイム（数分おき程度）の更新でも問題ないでしょう。
  よりリアルタイム性が必要であれば、BlueMapのWebSocketライブ機能や、あるいは完全自前実装で(B)のように差分適用するか、(B)と(A)の中間的に**BlueMapの生成したデータをNext.js側で適宜Fetchして反映**する方法も考えられます。
  例えばBlueMapのREST APIやディレクトリに対し、クライアントが定期的に「このチャンクのモデルが更新されたか？」を問い合わせ、更新されていれば新たに取得してシーンを置き換えるという仕組みです。BlueMap自体はブラウザ上で「Update Map」ボタンを押すと最新タイルを取得しますが、これを自動化するイメージです。
  **チャンクデータのロード戦略**も重要です。広大なワールド全体を一度にロードするのは不可能なので、ユーザの視点周辺のみを動的に読み込む**範囲選択読み込み**を実装します。これはちょうどMinecraftクライアントがやっている方式で、現在地を中心に一定範囲（例：半径8チャンク）のみメモリに保持し、それ以遠はアンロードします。俯瞰マップモードではユーザが広域を見渡すため、一時的にロード範囲を拡大し高高度からの画面表示に耐えうるようにします。その際、高度な実装では**詳細度のレベル（LOD）**を取り入れ、遠方は荒い解像度または2D投影で表示し、近距離のみ詳細な3Dモデルを表示することでパフォーマンスを維持します。BlueMapは低解像度タイルと高解像度タイルを使い分けていますが、本アプリでも必要に応じて、遠景は地形高さだけ反映した簡易メッシュや縮小テクスチャで代用するなど工夫します。ただしまずはシンプルに、描画距離を適切に制限してカメラ周囲のみ描画する方法で様子を見ます。描画範囲外に出たオブジェクトは`dispose()`でメモリ解放し、新たに範囲に入ったチャンクのデータをロードして追加するといった動的管理を行います。
  **チャンクデータのロード戦略**も重要です。広大なワールド全体を一度にロードするのは不可能なので、ユーザの視点周辺のみを動的に読み込む**範囲選択読み込み**を実装します。これはちょうどMinecraftクライアントがやっている方式で、現在地を中心に一定範囲（例：半径8チャンク）のみメモリに保持し、それ以遠はアンロードします。俯瞰マップモードではユーザが広域を見渡すため、一時的にロード範囲を拡大し高高度からの画面表示に耐えうるようにします。
  その際、高度な実装では**詳細度のレベル（LOD）**を取り入れ、遠方は荒い解像度または2D投影で表示し、近距離のみ詳細な3Dモデルを表示することでパフォーマンスを維持します。BlueMapは低解像度タイルと高解像度タイルを使い分けていますが、本アプリでも必要に応じて、遠景は地形高さだけ反映した簡易メッシュや縮小テクスチャで代用するなど工夫します。ただしまずはシンプルに、描画距離を適切に制限してカメラ周囲のみ描画する方法で様子を見ます。描画範囲外に出たオブジェクトは`dispose()`でメモリ解放し、新たに範囲に入ったチャンクのデータをロードして追加するといった動的管理を行います。
  以上のようにリアルタイム同期にはいくつかの方法がありますが、まとめると**「サーバー側でデータ変換/提供」**と**「クライアント/サーバー側で直接生データ処理」**のハイブリッドも視野に入れ、最適な方法を選定します。開発初期段階ではBlueMap等既存ソリューションで実現性を検証し、課題に応じて徐々に独自処理に切り替えていくアプローチがリスク低減につながるでしょう。

## Next.js 15（App Router）および React 19 に最適化した実装

Next.js 15のApp Router環境とReact 19世代に合わせ、本アプリの実装手法を最適化します。Next.js 13以降のApp Routerでは**デフォルトがReact Server Components**であるため、ブラウザAPIや動的挙動を扱う部分は**Client Component**として明示する必要があります。特にThree.jsやBabylon.jsを用いたレンダリングコンポーネントは、`window`やWebGLコンテキストにアクセスするため**'use client'**ディレクティブを付与してクライアントコンポーネントとして定義します。これにより、SSR時にそれらのコンポーネントはスキップされ、ブラウザ上でのみ初期化コードが実行されます。
さらに、App Routerでは**レイアウトとページを分離**できるため、本アプリではグローバルなレイアウト部分は可能な限りサーバーコンポーネントで実装し、動的な地図ビューワー部分のみクライアントコンポーネントにします。静的コンテンツはSSRされるようにし、SEOにも配慮します。一方、ワールド表示ページはクライアント主体で、App Routerの**Nested Routes**機能を利用して必要最小限の再レンダリングに抑えます。
**パフォーマンス最適化**の観点では、Next.jsの動的インポートを使って3Dエンジン関連の重たいモジュールを遅延ロードします。これにより初回ページロード時の負荷を減らし、ユーザが実際にワールドビューを開いたタイミングでライブラリをフェッチします。React 19の機能を活用して、`Suspense`や`useTransition`でローディング中の表示を制御し、並行レンダリングによる快適な操作感を目指します。3D表示と通常のReact UIを分離しつつ、必要に応じて<Html>コンポーネントでオーバーレイ表示させます。
データ取得についてはNext.jsのAPI Routeを活用できます。`app/api/**/route.ts`でNBTデータの読み出しを行い、SWRパターンやReact Queryでポーリングしつつ差分を反映します。Vercelではサーバレス関数として動作するため、負荷に応じてエッジ関数も検討します。セキュリティ面ではAPIへの認証や公開範囲の制御を行い、必要最小限の情報のみクライアントに送信します。
総じて、Next.js 15/React 19環境ではServer/Clientコンポーネントの適切な切り分けと最新のReact機能の活用がポイントです。複雑な3D処理部分は可能な限りオフロードし、ユーザ体験を損なわないように実装します。

## Vercel無料プランでのホスティング条件と制限

本アプリはVercelの無料プラン(Hobby)上で運用する前提です。主な制限と対策を整理します。

- **帯域・リソース制限**: 月100GBの帯域などがあり、圧縮データ配信やキャッシュ活用で抑えます。
- **ビルド容量・時間**: 大きなアセットは外部ストレージに置くなどしてビルドサイズを抑制します。
- **サーバレスの実行時間**: 重い処理はオフラインバッチや外部サービスに任せます。
- **長時間接続(WebSocket)** は公式には非推奨のためポーリングや外部リアルタイムサービスを検討します。
- **データベース利用**は含まれないため必要に応じて外部DBを組み合わせます。

無料枠でも運用可能ですが、データ量や処理負荷を意識した設計が必要です。

## 技術スタック・データ形式・セキュリティ上の追加考慮

- **使用技術まとめ**: Next.js 15とReact 19、TypeScriptを基盤とし、Three.js＋React Three Fiberを第一候補とします。BlueMapプラグインでワールドデータを取得し、必要に応じてPrismarineJSで処理を補完します。
- **データ形式と管理**: ワールドデータはAnvil形式。BlueMapのPRBM形式やNBTデータを扱い、クライアントには必要最小限の情報だけ送信します。
- **セキュリティとライセンス**: 公開範囲の制御や通信の暗号化、Mojang EULA遵守を意識し、機微情報は適切に保護します。
  以上、Next.js 15・React 19・TypeScriptを用いたマインクラフトワールド探索アプリの構築方法について、総合的な提案を示しました。段階的に技術検証を行いながら機能を拡張し、一人称視点と俯瞰ビューを切り替えられるハザードマッププラットフォームを目指します。

## 実際にマイクラワールドを表示するには

実際のワールドを読み込むには、まずサーバー管理者としてワールドフォルダにアクセスできる必要があります。以下は BlueMap を利用する例です。

1. **Minecraft サーバーに BlueMap プラグインを導入**し、ワールドの読み取り権限があることを確認します。サーバー起動後、`bluemap` ディレクトリに 3D タイルデータが生成されます。
2. 生成された `bluemap/web` フォルダをこのプロジェクトの `public/bluemap` にコピーします。権限が不足している場合はサーバー管理者に取得を依頼してください。
3. `/world` ページでは `public/bluemap` 配下の PRBM チャンクを読み込みます。React Three Fiber 等で PRBM を `BufferGeometry` に変換すればレンダリングできます。
4. ワールドを更新するには、サーバー側で BlueMap の再レンダリングを実行し、生成物を再度 `public/bluemap` に配置した上でアプリをデプロイし直します。

その他、PrismarineJS を用いて `.mca` ファイルを直接解析する方法もありますが、BlueMap を通す方が手軽です。
